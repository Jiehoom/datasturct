## 排序算法



## 简单排序

#### 冒泡排序(bubble sorting)

​	实现原理:1.每次比较相邻的元素,根据从大到小(还是从小到大)排序,将相邻的元素中较小(较大)的元素交换往后移

​	2.当一个元素已经确定之后,下次从头开始重复之前的操作,但是这次比较的次数减少一次;

​	因此可以看出冒泡排序中交换代码的执行次数是3*(n-1+...+0)次,时间复杂度为O(n^2);



### 选择排序(Select Sort)

​	实现原理:遍历容器,找到每个元素适合的位置;因此每确定一个元素的位置就要遍历一次容器,n个容器遍历(1+...+n)次,时间复杂度为0(n^2)



### 插入排序(Insert Sort)

​	实现原理:1.把所有的元素分为两组:已经排序好的和未排序的

​	2.找到未排序的第一个元素,向已经排序的组中进行插入

​	3.倒叙遍历已经排序好的元素,依次和待插入的元素进行比较,直到找到一个元素小于等于待插入元素,那么就把待插入元素放到这个位置,其他的元素向后移动一位

以上三种简单排序的时间复杂度最坏的情况是O(n^2) 最好的情况是O(n)

## 高级排序



### 	希尔排序

 实现原理:指定一个增长量h,按照增长量作为数据分组的依据,对数据进行分组,对分好的每一组进行插入排序,减小增长量,直到h为1

 h值的确定规则:不确定,不唯一的

 希尔排序是一个不可靠的排序;相同数据的顺序会和排序前不一致

 希尔排序的时间效率可以通过代码中的TestSortCompare.java比较,在最坏的排序情况下,时间的比较可以看到明显的差距